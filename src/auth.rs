use async_std::io::Cursor;
use futures_util::AsyncRead;
use isahc::config::{Configurable, RedirectPolicy};
use once_cell::sync::Lazy;
use openidconnect::core::{CoreClient, CoreIdToken, CoreProviderMetadata, CoreResponseType};
use openidconnect::{
    AuthenticationFlow, ClientId, CsrfToken, HttpRequest, HttpResponse, IdToken, IssuerUrl, Nonce,
    RedirectUrl, Scope, SubjectIdentifier,
};
use serde::{Deserialize, Serialize};
use tide::http::Method;
use tide::{Middleware, Next, Redirect, Request, StatusCode};

/// Middleware configuration.
#[derive(Debug, Deserialize)]
pub struct Config {
    /// Issuer URL used to A) retrieve the OpenID Connect provider
    /// metadata *and* B) validate that tokens are generated by the
    /// expected issuer.
    pub issuer_url: IssuerUrl,

    /// Our Client ID, as generated by the OpenID Connect provider.
    pub client_id: ClientId,

    /// URL to which the OpenID Connect provider will redirect authenticated
    /// requests; must be a URL registered with the provider.
    pub redirect_url: RedirectUrl,
}

pub struct OpenIdConnectMiddleware {
    login_path: String,
    callback_path: String,
    login_landing_path: String,
    redirect_url: RedirectUrl,
    client: CoreClient,
}

#[derive(Debug, Deserialize, Serialize)]
enum MiddlewareSessionState {
    PreAuth(CsrfToken, Nonce),
    PostAuth(String),
}

// Isahc recommends that you create a single client per "area of application"
// and reuse that client through your code. We have to create a global client
// instance (instead of putting the client in a struct and then having the
// `http_client` function be a trait function) because we need to pass the
// bare `http_client` function to the oauth2-rs crate and we cannot close
// over `self` when doing that.
static HTTP_CLIENT: Lazy<isahc::HttpClient> = Lazy::new(|| {
    isahc::HttpClient::builder()
        .redirect_policy(RedirectPolicy::None)
        .build()
        .expect("Unable to initialize Isahc client.")
});

#[derive(Debug, thiserror::Error)]
pub(crate) enum IsahcError {
    /// Error returned by Isahc crate.
    #[error("Isahc request failed")]
    Isahc(#[source] isahc::Error),
    /// Non-Isahc HTTP error.
    #[error("HTTP error")]
    Http(#[source] isahc::http::Error),
    /// I/O error.
    #[error("I/O error")]
    Io(#[source] std::io::Error),
}

async fn to_bytes<R>(reader: R) -> Result<Vec<u8>, IsahcError>
where
    R: AsyncRead + Unpin,
{
    // Create a cursor to a vector, which provides the vector with an
    // AsyncRead trait that appends to the vector.
    let mut writer = Cursor::new(Vec::new());

    // Asynchronously copy the data from the reader to the buffer.
    async_std::io::copy(reader, &mut writer)
        .await
        .map_err(IsahcError::Io)?;

    // Return the buffer inside of the reader.
    Ok(writer.into_inner())
}

async fn http_client(openid_request: HttpRequest) -> Result<HttpResponse, IsahcError> {
    let mut request_builder = isahc::Request::builder()
        .method(openid_request.method)
        .uri(openid_request.url.as_str());
    for (name, value) in &openid_request.headers {
        request_builder = request_builder.header(name.as_str(), value.as_bytes());
    }
    let request = request_builder
        .body(openid_request.body)
        .map_err(IsahcError::Http)?;

    let response = HTTP_CLIENT
        .send_async(request)
        .await
        .map_err(IsahcError::Isahc)?;

    Ok(HttpResponse {
        status_code: response.status(),
        headers: response.headers().to_owned(),
        body: to_bytes(response.into_body()).await?,
    })
}

impl OpenIdConnectMiddleware {
    pub async fn new(config: &Config) -> Self {
        // Get the OpenID Connect provider metadata.
        let provider_metadata =
            CoreProviderMetadata::discover_async(config.issuer_url.clone(), http_client)
                .await
                .expect("Unable to load OpenID Connect provider metadata.");

        // Create the OpenID Connect client.
        let client =
            CoreClient::from_provider_metadata(provider_metadata, config.client_id.clone(), None)
                .set_redirect_uri(config.redirect_url.clone());

        Self {
            login_path: "/login".to_string(),
            callback_path: "/callback".to_string(),
            login_landing_path: "/".to_string(),
            redirect_url: config.redirect_url.clone(),
            client,
        }
    }

    async fn generate_redirect<State>(&self, mut req: Request<State>) -> tide::Result
    where
        State: Clone + Send + Sync + 'static,
    {
        let request = self.client.authorize_url(
            AuthenticationFlow::Hybrid(vec![CoreResponseType::IdToken]),
            CsrfToken::new_random,
            Nonce::new_random,
        );
        let (mut authorize_url, csrf_token, nonce) = request.url();

        authorize_url
            .query_pairs_mut()
            .append_pair("response_mode", "form_post");

        // Initialize the middleware's session state so that we can
        // validate the login after the user completes the authentication
        // flow.
        req.session_mut()
            .insert(
                SESSION_KEY,
                MiddlewareSessionState::PreAuth(csrf_token, nonce),
            )
            .map_err(|error| tide::http::Error::new(StatusCode::InternalServerError, error))?;

        Ok(Redirect::new(&authorize_url).into())
    }

    async fn handle_callback<State>(&self, mut req: Request<State>) -> tide::Result
    where
        State: Clone + Send + Sync + 'static,
    {
        // Get the middleware state from the session. If this fails then
        // A) the browser got to the callback URL without actually going
        // through the auth process, or B) more likely, the session
        // middleware is configured with Strict cookies instead of Lax
        // cookies. We cannot tell at this level which error occurred,
        // so we just reject the request and log the error.
        let session = req.session();
        let storage = session.get::<MiddlewareSessionState>(SESSION_KEY);

        if let Some(MiddlewareSessionState::PreAuth(csrf_token, nonce)) = storage {
            // Extract the OpenID callback information and verify the CSRF
            // state.
            #[derive(Deserialize)]
            struct OpenIdCallback {
                id_token: CoreIdToken,
                state: String,
            }

            //let query = req.url().fragment().unwrap_or("");
            let callback_data: OpenIdCallback = req.body_form().await?;

            if &callback_data.state != csrf_token.secret() {
                return Err(tide::http::Error::from_str(
                    StatusCode::Unauthorized,
                    "Invalid CSRF state.",
                ));
            }

            // Get the claims and verify the nonce.
            let claims = callback_data
                .id_token
                .claims(&self.client.id_token_verifier(), &nonce)
                .map_err(|error| tide::http::Error::new(StatusCode::Unauthorized, error))?;

            let email = claims.email().ok_or_else(|| {
                tide::http::Error::from_str(
                    StatusCode::InternalServerError,
                    "OpenID Connect server did not return an email claim.",
                )
            })?;

            let id = email.as_str().split('@').next().ok_or_else(|| {
                tide::http::Error::from_str(
                    StatusCode::InternalServerError,
                    "Could not strip off the email domain",
                )
            })?;

            // Add the user id to the session state in order to mark this
            // session as authenticated.
            req.session_mut()
                .insert(
                    SESSION_KEY,
                    MiddlewareSessionState::PostAuth(id.to_string()),
                )
                .map_err(|error| tide::http::Error::new(StatusCode::InternalServerError, error))?;

            // The user has logged in; redirect them to the main site.
            Ok(Redirect::new(&self.login_landing_path).into())
        } else {
            tide::log::warn!(
                    "Missing OpenID Connect state in session; make sure SessionMiddleware is configured with SameSite::Lax (but do *not* mutate server-side state on GET requests if you make that change!)."
                );
            Err(tide::http::Error::from_str(
                StatusCode::InternalServerError,
                "Missing authorization state.",
            ))
        }
    }
}

const SESSION_KEY: &str = "tide.oidc";

pub(crate) enum OpenIdConnectRequestExtData {
    Unauthenticated {},
    Authenticated { user_id: String },
}

#[tide::utils::async_trait]
impl<State> Middleware<State> for OpenIdConnectMiddleware
where
    State: Clone + Send + Sync + 'static,
{
    async fn handle(&self, mut req: Request<State>, next: Next<'_, State>) -> tide::Result {
        // Is this URL one of the URLs that we need to intercept as part
        // of the OpenID Connect auth process? If so, apply the appropriate
        // part of the auth process according to the URL. If not, verify
        // that the request is authenticated, and if not, redirect the
        // browser to the login URL. And if they are authenticated, then
        // just proceed to the handler (after populating the request extension
        // fields).
        let path = req.url().path();

        // the AFDS server is buggy and uses & instead of ?... Damn
        //let path = &path[..path.rfind('&').unwrap_or(path.len())];

        if req.method() == Method::Get && path == self.login_path {
            self.generate_redirect(req).await
        } else if req.method() == Method::Post && path == self.callback_path {
            self.handle_callback(req).await
        } else {
            // Get the middleware's session state (which will *not* be
            // present if the browser has not yet gone through the auth
            // process), then augment the request with the authentication
            // status.
            match req.session().get(SESSION_KEY) {
                Some(MiddlewareSessionState::PostAuth(subject)) => {
                    req.set_ext(OpenIdConnectRequestExtData::Authenticated {
                        user_id: subject.to_string(),
                    })
                }
                _ => req.set_ext(OpenIdConnectRequestExtData::Unauthenticated {}),
            };

            // Call the downstream middleware.
            Ok(next.run(req).await)
        }
    }
}
