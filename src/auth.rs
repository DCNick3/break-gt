use async_std::io::Cursor;
use futures_util::AsyncRead;
use isahc::config::{Configurable, RedirectPolicy};
use once_cell::sync::Lazy;
use openidconnect::core::{CoreClient, CoreIdToken, CoreProviderMetadata, CoreResponseType};
use openidconnect::{
    AuthenticationFlow, ClientId, CsrfToken, HttpRequest, HttpResponse, IssuerUrl, Nonce,
    RedirectUrl,
};
use serde::{Deserialize, Serialize};
use tide::http::Method;
use tide::{Middleware, Next, Redirect, Request, Route, StatusCode};

/// Middleware configuration.
#[derive(Debug, Deserialize)]
pub struct Config {
    /// Issuer URL used to A) retrieve the OpenID Connect provider
    /// metadata *and* B) validate that tokens are generated by the
    /// expected issuer.
    pub issuer_url: IssuerUrl,

    /// Our Client ID, as generated by the OpenID Connect provider.
    pub client_id: ClientId,

    /// URL to which the OpenID Connect provider will redirect authenticated
    /// requests; must be a URL registered with the provider.
    pub redirect_url: RedirectUrl,
}

pub struct OpenIdConnectMiddleware {
    login_path: String,
    callback_path: String,
    login_landing_path: String,
    client: CoreClient,
}

#[derive(Debug, Deserialize, Serialize)]
enum MiddlewareSessionState {
    PreAuth(CsrfToken, Nonce),
    PostAuth(String),
}

// Isahc recommends that you create a single client per "area of application"
// and reuse that client through your code. We have to create a global client
// instance (instead of putting the client in a struct and then having the
// `http_client` function be a trait function) because we need to pass the
// bare `http_client` function to the oauth2-rs crate and we cannot close
// over `self` when doing that.
static HTTP_CLIENT: Lazy<isahc::HttpClient> = Lazy::new(|| {
    isahc::HttpClient::builder()
        .redirect_policy(RedirectPolicy::None)
        .build()
        .expect("Unable to initialize Isahc client.")
});

#[derive(Debug, thiserror::Error)]
pub(crate) enum IsahcError {
    /// Error returned by Isahc crate.
    #[error("Isahc request failed")]
    Isahc(#[source] isahc::Error),
    /// Non-Isahc HTTP error.
    #[error("HTTP error")]
    Http(#[source] isahc::http::Error),
    /// I/O error.
    #[error("I/O error")]
    Io(#[source] std::io::Error),
}

async fn to_bytes<R>(reader: R) -> Result<Vec<u8>, IsahcError>
where
    R: AsyncRead + Unpin,
{
    // Create a cursor to a vector, which provides the vector with an
    // AsyncRead trait that appends to the vector.
    let mut writer = Cursor::new(Vec::new());

    // Asynchronously copy the data from the reader to the buffer.
    async_std::io::copy(reader, &mut writer)
        .await
        .map_err(IsahcError::Io)?;

    // Return the buffer inside of the reader.
    Ok(writer.into_inner())
}

async fn http_client(openid_request: HttpRequest) -> Result<HttpResponse, IsahcError> {
    let mut request_builder = isahc::Request::builder()
        .method(openid_request.method)
        .uri(openid_request.url.as_str());
    for (name, value) in &openid_request.headers {
        request_builder = request_builder.header(name.as_str(), value.as_bytes());
    }
    let request = request_builder
        .body(openid_request.body)
        .map_err(IsahcError::Http)?;

    let response = HTTP_CLIENT
        .send_async(request)
        .await
        .map_err(IsahcError::Isahc)?;

    Ok(HttpResponse {
        status_code: response.status(),
        headers: response.headers().to_owned(),
        body: to_bytes(response.into_body()).await?,
    })
}

impl OpenIdConnectMiddleware {
    pub async fn new(config: &Config) -> Self {
        // Get the OpenID Connect provider metadata.
        let provider_metadata =
            CoreProviderMetadata::discover_async(config.issuer_url.clone(), http_client)
                .await
                .expect("Unable to load OpenID Connect provider metadata.");

        // Create the OpenID Connect client.
        let client =
            CoreClient::from_provider_metadata(provider_metadata, config.client_id.clone(), None)
                .set_redirect_uri(config.redirect_url.clone());

        Self {
            login_path: "/login".to_string(),
            callback_path: "/callback".to_string(),
            login_landing_path: "/".to_string(),
            client,
        }
    }

    async fn generate_redirect<State>(&self, mut req: Request<State>) -> tide::Result
    where
        State: Clone + Send + Sync + 'static,
    {
        let request = self.client.authorize_url(
            AuthenticationFlow::Hybrid(vec![CoreResponseType::IdToken]),
            CsrfToken::new_random,
            Nonce::new_random,
        );
        let (mut authorize_url, csrf_token, nonce) = request.url();

        authorize_url
            .query_pairs_mut()
            .append_pair("response_mode", "form_post");

        // Initialize the middleware's session state so that we can
        // validate the login after the user completes the authentication
        // flow.
        req.session_mut()
            .insert(
                SESSION_KEY,
                MiddlewareSessionState::PreAuth(csrf_token, nonce),
            )
            .map_err(|error| tide::http::Error::new(StatusCode::InternalServerError, error))?;

        Ok(Redirect::new(&authorize_url).into())
    }

    async fn handle_callback<State>(&self, mut req: Request<State>) -> tide::Result
    where
        State: Clone + Send + Sync + 'static,
    {
        // Get the middleware state from the session. If this fails then
        // A) the browser got to the callback URL without actually going
        // through the auth process, or B) more likely, the session
        // middleware is configured with Strict cookies instead of Lax
        // cookies. We cannot tell at this level which error occurred,
        // so we just reject the request and log the error.
        let session = req.session();
        let storage = session.get::<MiddlewareSessionState>(SESSION_KEY);

        if let Some(MiddlewareSessionState::PreAuth(csrf_token, nonce)) = storage {
            // Extract the OpenID callback information and verify the CSRF
            // state.
            #[derive(Deserialize)]
            struct OpenIdCallback {
                id_token: CoreIdToken,
                state: String,
            }

            //let query = req.url().fragment().unwrap_or("");
            let callback_data: OpenIdCallback = req.body_form().await?;

            if &callback_data.state != csrf_token.secret() {
                return Err(tide::http::Error::from_str(
                    StatusCode::Unauthorized,
                    "Invalid CSRF state.",
                ));
            }

            // Get the claims and verify the nonce.
            let claims = callback_data
                .id_token
                .claims(&self.client.id_token_verifier(), &nonce)
                .map_err(|error| tide::http::Error::new(StatusCode::Unauthorized, error))?;

            let email = claims.email().ok_or_else(|| {
                tide::http::Error::from_str(
                    StatusCode::InternalServerError,
                    "OpenID Connect server did not return an email claim.",
                )
            })?;

            let id = email.as_str().split('@').next().ok_or_else(|| {
                tide::http::Error::from_str(
                    StatusCode::InternalServerError,
                    "Could not strip off the email domain",
                )
            })?;
            let id = id.replace('.', "_"); // I hope nobody gets the same id =)

            // Add the user id to the session state in order to mark this
            // session as authenticated.
            req.session_mut()
                .insert(
                    SESSION_KEY,
                    MiddlewareSessionState::PostAuth(id.to_string()),
                )
                .map_err(|error| tide::http::Error::new(StatusCode::InternalServerError, error))?;

            // The user has logged in; redirect them to the main site.
            Ok(Redirect::new(&self.login_landing_path).into())
        } else {
            tide::log::warn!(
                    "Missing OpenID Connect state in session; make sure SessionMiddleware is configured with SameSite::Lax (but do *not* mutate server-side state on GET requests if you make that change!)."
                );
            Err(tide::http::Error::from_str(
                StatusCode::InternalServerError,
                "Missing authorization state.",
            ))
        }
    }
}

const SESSION_KEY: &str = "tide.oidc";

pub(crate) enum OpenIdConnectRequestExtData {
    Unauthenticated {},
    Authenticated { user_id: String },
}

#[tide::utils::async_trait]
impl<State> Middleware<State> for OpenIdConnectMiddleware
where
    State: Clone + Send + Sync + 'static,
{
    async fn handle(&self, mut req: Request<State>, next: Next<'_, State>) -> tide::Result {
        // Is this URL one of the URLs that we need to intercept as part
        // of the OpenID Connect auth process? If so, apply the appropriate
        // part of the auth process according to the URL. If not, verify
        // that the request is authenticated, and if not, redirect the
        // browser to the login URL. And if they are authenticated, then
        // just proceed to the handler (after populating the request extension
        // fields).
        let path = req.url().path();

        // the AFDS server is buggy and uses & instead of ?... Damn
        //let path = &path[..path.rfind('&').unwrap_or(path.len())];

        if req.method() == Method::Get && path == self.login_path {
            self.generate_redirect(req).await
        } else if req.method() == Method::Post && path == self.callback_path {
            self.handle_callback(req).await
        } else {
            // Get the middleware's session state (which will *not* be
            // present if the browser has not yet gone through the auth
            // process), then augment the request with the authentication
            // status.
            match req.session().get(SESSION_KEY) {
                Some(MiddlewareSessionState::PostAuth(user_id)) => {
                    req.set_ext(OpenIdConnectRequestExtData::Authenticated { user_id })
                }
                _ => req.set_ext(OpenIdConnectRequestExtData::Unauthenticated {}),
            };

            // Call the downstream middleware.
            Ok(next.run(req).await)
        }
    }
}

/// Provides access to request-level authentication data.
pub trait OpenIdConnectRequestExt {
    /// Returns `true` if the request is authenticated, `false`
    /// otherwise.
    fn is_authenticated(&self) -> bool;

    /// Gets the Identity Provider-specific user id of the authenticated
    /// user, or `None` if the session has not been authenticated.
    fn user_id(&self) -> Option<String>;
}

impl<State> OpenIdConnectRequestExt for Request<State>
where
    State: Send + Sync + 'static,
{
    fn is_authenticated(&self) -> bool {
        matches!(
            self.auth_state(),
            OpenIdConnectRequestExtData::Authenticated { .. }
        )
    }

    fn user_id(&self) -> Option<String> {
        match self.auth_state() {
            OpenIdConnectRequestExtData::Authenticated { user_id, .. } => Some(user_id.clone()),
            _ => None,
        }
    }
}

pub(crate) trait OpenIdConnectRequestExtInternal {
    fn auth_state(&self) -> &OpenIdConnectRequestExtData;
}

impl<State> OpenIdConnectRequestExtInternal for Request<State>
where
    State: Send + Sync + 'static,
{
    fn auth_state(&self) -> &OpenIdConnectRequestExtData {
        self.ext()
            .expect("You must install OpenIdConnectMiddleware to access the Open ID request data.")
    }
}

/// Authorization extensions to Tide [Route](tide::Route) handles.
///
/// Adds an [`authenticated()`](OpenIdConnectRouteExt::authenticated)
/// function to Tide's Route handles which can be used to require
/// authentication on specific routes/HTTP methods. Without this
/// extension, users must manually navigate to the login path in order
/// to begin the authentication process. This extension can be placed
/// before any route in order to force unauthenticated requests to that
/// route to go through the login process. This is an easy way to
/// protect your routes without requiring that they individually check
/// the request's authentication status.
///
/// By default, the `authenticated()` route extension uses the standard
/// HTTP redirect process -- `302 Found` with a `Location` header. This
/// works well for user navigation, but may run afoul of HTTP
/// [Cross-Origin Resource Sharing] (CORS) protections if the request
/// was initiated by a client-side `XMLHttpRequest` or `fetch`.
///
/// For example, redirecting certain forms of `POST` requests requires
/// that the *Identity Provider's* authorization endpoint return the
/// proper CORS headers during the "preflight" phase of the HTTP
/// request, otherwise the request will be blocked by the browser and
/// the authentication process will fail.
///
/// In those situations your client-side application will need to
/// perform the redirect. See the
/// [`redirect_strategy`](crate::redirect_strategy) module for more
/// information.
///
/// [Cross-Origin Resource Sharing]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
///
/// # Example
///
/// ```no_run
/// use tide_openidconnect::{self, OpenIdConnectRouteExt};
/// # type Request = tide::Request<()>;
/// # async_std::task::block_on(async {
/// # let mut app = tide::new();
///
/// app.at("/").get(|req: Request| async { Ok("Unprotected route") });
///
/// app.at("/secret")
///     .authenticated()
///     .get(|req: Request| async { Ok("Protected GET") })
///     .post(|req: Request| async { Ok("Protected POST") });
///
/// app.at("/semi-secret")
///     .get(|req: Request| async { Ok("*Unprotected* GET") })
///     .authenticated()
///     .post(|req: Request| async { Ok("Protected POST") });
///
/// # })
/// ```
pub trait OpenIdConnectRouteExt {
    /// Requires authentication on the subsequent portions of this
    /// route, redirecting the browser to the login page if the request
    /// is not authenticated.
    fn authenticated(&mut self) -> &mut Self;
}

impl<'a, State: Clone + Send + Sync + 'static> OpenIdConnectRouteExt for Route<'a, State> {
    fn authenticated(&mut self) -> &mut Self {
        self.with(MustAuthenticateMiddleware {})
    }
}

struct MustAuthenticateMiddleware;

#[tide::utils::async_trait]
impl<State> Middleware<State> for MustAuthenticateMiddleware
where
    State: Clone + Send + Sync + 'static,
{
    async fn handle(&self, req: Request<State>, next: Next<'_, State>) -> tide::Result {
        // Is the request authenticated? If so, forward the request to
        // the next item in the middleware chain. Otherwise, redirect
        // the browser to the login page.
        match req.auth_state() {
            OpenIdConnectRequestExtData::Authenticated { .. } => {
                tide::log::debug!(
                    "Authenticated request; forwarding request to next item in middleware chain."
                );
                Ok(next.run(req).await)
            }
            OpenIdConnectRequestExtData::Unauthenticated {} => {
                tide::log::debug!("Unauthenticated request; returning 401");
                Err(tide::http::Error::from_str(
                    StatusCode::Unauthorized,
                    "Auth required to access this endpoint",
                ))
            }
        }
    }
}
